#+OPTIONS: reveal_title_slide:nil num:nil
#+REVEAL_THEME: black

* Hello!
** Robert Dallas Gray
robert@geo.me
* Geo.me
* Geospatial applications
* Client logos
** 
  :PROPERTIES:
  :reveal_background: ./btwifiapi.gif
  :END:
** 
  :PROPERTIES:
  :reveal_background: ./btsport.gif
  :END:
** BUPA
** Pennzoil
** Truckrouting
** 
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
** EC2
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
API servers, load balancing, scaling 
** RDS
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
Databases (Postgres/GIS)
** S3
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
Static file storage, artefacts 
** Route 53
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
Routing
** Elasticache
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
Ephemeral storage, caching
** SQS, SNS
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
Fanning to queues for offline tasks
** CloudFront
  :PROPERTIES:
  :reveal_background: ./aws.svg
  :END:
Edge caching and ... ?
* Serverless Architecture
** 
  :PROPERTIES:
  :reveal_background: ./aws-architecture-rds.svg
  :reveal_background_size: 400px
  :END:
** 
  :PROPERTIES:
  :reveal_background: ./aws-architecture-ec2.svg
  :reveal_background_size: 400px
  :END:
** 
  :PROPERTIES:
  :reveal_background: ./aws-architecture-asg.svg
  :reveal_background_size: 400px
  :END:
** 
  :PROPERTIES:
  :reveal_background: ./aws-architecture-elb.svg
  :reveal_background_size: 400px
  :END:
** 
  :PROPERTIES:
  :reveal_background: ./aws-architecture-cf.svg
  :reveal_background_size: 400px
  :END:
** 
  :PROPERTIES:
  :reveal_background: ./aws-architecture-route53.svg
  :reveal_background_size: 400px
  :END:

** We made a small number of full-stack monolithic applications

They were built ad-hoc with old-style FE tools.  Some of these
applications grew to support multiple, often disparate groups of
users.  Eventually some had many different modes, with different UI,
auth, etc.  This was (is!) difficult to maintain.

** We knew we would be doing more front-end work

We started to develop front-end only apps using newer technologies.

We thought we could have these be completely static, hosted on S3, but
an issue we encountered early on was Cross-Origin restrictions
(browsers won't let applications XHR to endpoints on different
domains). CORS didn't work well on IE particularly. Cookies were a
problem. So we wanted our FE apps to be on the same domain as their
back ends. (DIAGRAM)

** We took on a new project

It would necessitate lots of front-end apps, all different in UI and
other configuration. Each app would speak to a similar API drawing
from the same set of data. (DIAGRAM)

** Initially we hosted them inside the monolithic back-end app

(DIAGRAM -- different paths per app)

No cross origin problems!

This became problematic because

- Each app might need its own SSL configuration, its own endpoint,
  etc.
- The monolithic app changed whenever one of the internal apps changed
- Long paths

** We moved to using small Nginx servers in EC2

Proxying inside Nginx so that a path (/api) proxied to the API server (DIAGRAM).

This was better but still a pain.

- We had to maintain a full production environment for each app (scaling, load-balancing etc.)
- There were issues with Nginx caching DNSs, so when a back-end was
  redeployed everything stopped working
- Expensive

** We reckoned we could use CloudFront for proxying

(DIAGRAM -- CF, S3, API Server)

- SSL on CloudFront was prohibitively expensive (Find out exactly how much)
- SNI didn't work with technologies we needed (Find out which ones)

** Google stopped supporting something

(Find out what)

It meant we could use SNI (DIAGRAM)
